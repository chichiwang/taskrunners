
Hello, everybody! Thank you for being here tonight. My name is Chi-chi Wang. It's very nice to meet you.

A little bit about my background: I joined Enova International earlier this year as a UI developer. Before joining Enova I worked at Electronic Arts on their Social Mobile Publishing team working on marketing campaigns for their mobile games. After EA I joined a digital agency called Ignition Creative. There I got to work with some very talented teams building award winning web campaigns for movie studios and companies like Disney and Toyota.

I'm here tonight to talk to you about javascript task runners. Now I've spent my entire career as a developer specialized in the front-end. And when you work on front-end web at scale you quickly learn that there are lots of repetive tasks that need to be executed in the course of development.

You might be using tools like Coffeescript or Babel. Or CSS pre-compilers, like Sass or Less, that require a build step. You might have your codebase distributed into discrete files that need to be concatenated for your build to run. Perhaps you're writing components in a modular fashion that need to be bundled, or maybe you're using a linter to enforce code conventions across your team. You definitely want to be using live-reload to update your browser every time you save a file.

When you build for production you usually need to cross your T's and dot your I's: things like building sprites, optimizing images, minifying your scripts and stylesheets.

Taken together all of these tasks can be a lot to manage, especially across a team. This is where task runners come in: task runners automate your repetitive tasks.

So what exactly is a task runner? A task runner, sometimes called a build system, allows you to define and execute tasks from the command line. They contain a configuration for you to define everything that needs to happen when you execute a given task. They're node applications that can be included in your package.json file and configurations can be commited to the repository for everybody to use on the project.

This is going to be a brief talk, so I'm only going to give you a quick overview of the three most popular task runners: Grunt, Brunch, and Gulp. Now there are other task runners, build systems, and alternatives like bundling systems out there (think Webpack) - but in the interest of keeping this talk short I will only be going over my favorites. Let's get started.

First up we have Grunt. Arguably the most popular and widely used task runner in the javascript community. Grunt's core philosophy is configurability. Every little chore you need done can be configured. And needs to be configured. This is done through a Gruntfile using Grunt's API and configuration objects for your plugins.

Why would you choose Grunt? Grunt boasts the largest user base of all of the task runners on the market. This means you are very likely to find answers to any problems you run into on StackOverflow. This also provides Grunt with an astonishing number of user-created plugins. Plugins provide utility like image optimization, minification, and so on.

As you would expect Grunt is also about the most configurable task runner on the market. Maybe your application has very weird build steps, or a crazy file structure. Grunt's got you covered.

Additionally, any tasks you write can be packaged as plugins to be reused or shared.

So what are the biggest pain points with Grunt? Well, it's very easy to end up with large, bloated configuration files that are difficult to read. So... that's one. Even if you start off with a boilerplate config, maybe generated by a tool like Yeoman, you'll need to decipher the damn thing to figure out how to customize it for your build.

But Grunt's greatest sin is the excruciatingly slow build times. So, this is how Grunt works: Grunt reads in your files from disk to apply a transformation to them for a given task (this can be compiling, minifying, concatenating, whatever), then it writes the result back out to disk. Then it needs to read those files back in for the next task to apply it's transformations. This can easily lead to you having to wait over 10 seconds every time you press save to wait for Grunt to finish all of it's tasks.

While this problem can be alleviated with the help of other tools or plugins that introduce concurrency to Grunt tasks, or allow transformations to be applied in buffer memory, those will add more complexity to your build tools.

This is an old Gruntfile from an actual project I worked on, and it was the first Gruntfile I actually put together for the team. As you can see I am configuring my tasks using config objects in object notation.

This Gruntfile came from a Yeoman generator that I spent hours modifying to fit the needs of our build.

And while this did everything we needed it to do for our project, you can see that this is a ridiculously large file. It's nearly 400 lines of task definitions.

Next up we have Brunch. When I found Brunch it was a breath of fresh air. Brunch has actually been around for a long time but relatively few people seem to have heard of it or use it. Brunch's core philosophy is convention over configuration. What that means is that this particular build system doesn't believe you should be spending all of your time reading, writing, or editing tasks. Brunch wants to get you set up and then get out of your way.

Again, Brunch emphasizes convention over configuration: it assumes a generalized build. By default, Brunch expects a particular file structure and provides you with the commands to run a watcher, tests, and to build for production. While this may sound limiting I assure you it's not. Brunch still has a configuration file, and you can tweak it as much as you'd like, but a vast majority of builds will work right out of the box.

This leads to very tiny configuration files. Brunch also provides module bundling and bundle splitting out of the box in the CommonJS convention. So they expect you to work in a modular fashion. Again, you can change this in configuration.

Another great thing about Brunch is that the plugins are mostly plug-and-play. You add the plugins to your package.json, and you usually don't need to set them up. They work automatically. You can add both a coffeescript compiler and a javascript minifier and they know what to do and in what order without any input from you.

Additionally Brunch boasts a lightning fast watch system. Unlike Grunt, which reads and writes to disk for every task, Brunch keeps its transforms in buffer memory, only rebuilding the files affected by the last save. That means you don't even think about it. You can work uninterrupted.

All of this makes Brunch the fastest up-and-running task runner I've encountered. Because everything works as if by magic.

On the downside, everything works as if by magic. If you find that a plugin doesn't work the way you need it to, or that you have certain unique cases in your build steps, it can be difficult to figure out how to get Brunch to play ball. This means that Brunch is not ideal for complex processes - but I've found that this is not the case for most builds.

Brunch also has the smallest user-base of the three task runners I'm talking about tonight. I don't know if it's poor marketing or what, but Brunch has the smallest ecosystem of plugins of the three. I've actually had to write my own Brunch plugin to handle cjsx files (coffeescript plus jsx) for a project I worked on.

So let's take a look at a Brunch config. Nice, right? Incredibly, I've found these 8 lines of configuration to work for a large number of use cases. Very rarely I've had to write additional configurations for plugins (things like linting rules).

Finally, we have Gulp. Gulp is probably Grunt's greatest competitor in terms of popularity and user base. The philosophy here is code over configuration. What this means is that rather than using config objects to define what your plugins do, you actually write Node.js code to define your tasks.

In Gulp you write your tasks using Node Streams. If you've never used Node Streams they are inspired by Unix Pipes, where you can chain the output of one operation into the input of another. This leads to very comprehensible configuration files. Since the configuration is code, developers who have never seen Gulp can more easily understand what is happening.

Gulp has a fairly large community of users who have written thousands of plugins. And like Brunch, Gulp applies its file transformations in buffer memory for a lightning fast build process.

The only real downsides to Gulp are that certain limitations in the system are unintuitive. There are operations (like deleting files) or edge cases that you wouldn't expect or even know exist. And for smaller builds Gulp may be a bit of overkill.

Let's take a look at a sample Gulpfile. As you can see, you are explicitly defining your plugins, and then defining tasks where you pipe file sources through plugin transformations and finally drop them off at a file destination.

This file is not too large, and I find it to still be fairly comprehensible.

That concludes my overview of Grunt, Brunch, and Gulp. I'm not going to endorse one of these build systems over the others - I think that they all have their strengths and weaknesses and Grunt may be better for one build while Brunch is better for another.

I encourage you to explore all of these task runners to learn which one best suits your needs. Maybe it's Grunt's enormous ecosystem and support. Maybe it's Brunch's speed and simplicity. Or you might want Gulp's speed and flexibility.

You can find this slide deck online at taskrunners dot mister chi-chi wang dot com. I've included some links to resources you can use to learn more.

Thank you and good night :)